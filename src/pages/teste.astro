---
// Cards.astro
const cards = [
  { title: "Card One", description: "This is the description for card one." },
  { title: "Card Two", description: "This is the description for card two." },
  { title: "Card Three", description: "This is the description for card three." },
  { title: "Card Four", description: "This is the description for card four." },
];
---
<style>
:root{
  --card-pad: 1rem;
  --reveal-duration: 300ms;
  --title-duration: 200ms;
  --desc-delay: 80ms;
}

.grid {
  display: grid;
  gap: 1rem;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}

/* Card base */
.card {
  position: relative;
  padding: var(--card-pad);
  background: white;
  border-radius: 12px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.08);
  overflow: hidden;
  cursor: pointer;
  min-height: 110px;
  outline: none;
}

/* Title / description styles share transitions */
.title, .desc {
  transition: opacity var(--reveal-duration) ease,
              transform var(--reveal-duration) ease;
  will-change: opacity, transform;
}

/* Default: title visible, description hidden (and slightly shifted) */
.title {
  opacity: 1;
  transform: translateY(0);
  margin: 0;
  font-size: 1.05rem;
  font-weight: 600;
}

.desc {
  position: absolute;
  left: var(--card-pad);
  right: var(--card-pad);
  top: var(--card-pad);
  margin: 0;
  opacity: 0;
  transform: translateY(8px);
  pointer-events: none;
  transition-delay: 0ms;
}

/* Reveal state: description visible, title hidden */
.card.reveal .title {
  opacity: 0;
  transform: translateY(-8px);
  transition-duration: var(--title-duration);
}

.card.reveal .desc {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
  transition-delay: var(--desc-delay);
}

/* Hiding state used while the description fades out.
   Keeps the title hidden until the fade finishes. */
.card.hiding .title {
  opacity: 0 !important;
  transform: translateY(-8px);
}

.card.hiding .desc {
  opacity: 0;
  transform: translateY(8px);
  transition-delay: 0ms;
}
</style>

<div class="grid">
  {cards.map((c, i) => (
    <div class="card" data-idx={i} tabindex="0" role="group" aria-labelledby={`t-${i}`} aria-describedby={`d-${i}`}>
      <h3 id={`t-${i}`} class="title">{c.title}</h3>
      <p id={`d-${i}`} class="desc" aria-hidden="true">{c.description}</p>
    </div>
  ))}
</div>

<script type="module">
/*
 Client behavior:
  - on mouseenter / focusin -> show immediately (clear timers)
  - on mouseleave / focusout  -> wait LINGER_MS, then start hide animation (hiding class),
                                then after HIDE_MS remove reveal/hiding so title returns
*/
(() => {
  const LINGER_MS = 600; // time description stays visible AFTER pointer leaves
  const HIDE_MS = 260;   // duration of the fade-out animation (match CSS var --reveal-duration)

  const cards = Array.from(document.querySelectorAll('.card'));
  const timers = new Map(); // maps idx -> { linger: timeoutId, hide: timeoutId }

  function clearTimers(idx){
    const t = timers.get(idx);
    if (!t) return;
    if (t.linger) { clearTimeout(t.linger); t.linger = null; }
    if (t.hide) { clearTimeout(t.hide); t.hide = null; }
  }

  function show(card){
    const idx = card.dataset.idx;
    clearTimers(idx);
    card.classList.remove('hiding');
    card.classList.add('reveal');
    const desc = card.querySelector('.desc');
    if (desc) desc.setAttribute('aria-hidden', 'false');
  }

  function leaveStart(card){
    const idx = card.dataset.idx;
    clearTimers(idx);
    // linger first
    const lingerId = setTimeout(() => {
      // start hide animation but keep reveal present so title stays hidden during fade-out
      card.classList.add('hiding');
      // after the fade-out duration remove both classes returning to default (title visible)
      const hideId = setTimeout(() => {
        card.classList.remove('reveal', 'hiding');
        const desc = card.querySelector('.desc');
        if (desc) desc.setAttribute('aria-hidden', 'true');
        // clear stored timers
        timers.delete(idx);
      }, HIDE_MS);
      timers.set(idx, { linger: null, hide: hideId });
    }, LINGER_MS);

    timers.set(idx, { linger: lingerId, hide: null });
  }

  cards.forEach(card => {
    // pointer
    card.addEventListener('mouseenter', () => show(card));
    card.addEventListener('mouseleave', () => leaveStart(card));
    // keyboard accessibility
    card.addEventListener('focusin', () => show(card));
    card.addEventListener('focusout', () => leaveStart(card));

    // simple mobile behavior: tap toggles reveal (optional)
    card.addEventListener('click', (e) => {
      if (!('ontouchstart' in window)) return; // only on touch devices
      if (card.classList.contains('reveal')) {
        leaveStart(card);
      } else {
        show(card);
      }
    });
  });
})();
</script>
